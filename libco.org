* Intrduction
  It provides a way to run multi-routines in one thread. These routines can perform as threads created by pthread. For example conditional wait, socket send/recv. libco manage these routes in userspace with epoll in linux or kqueue in apple.

* libco split
** key code
	coctx_swap(&(curr->ctx),&(pending_co->ctx) ); //switch between current thread and pending route.
** co_closure.h
   It is a file seems not related with other files. The basic technology of this file is to create class has members = paramters in co_func, has parent class stCoClosure_t; then these objects can be put into vector and be called one by one.
   If we expand(g++ -E ) the example_closure.cpp, we will find:
*** co_ref( ref,total,v2,m);
    typedef typeof( total ) typeof_total;
    typedef typeof( v2 ) typeof_v2;
    typedef typeof( m ) typeof_m;
    class type_ref{
        public: typeof_total & total;
        typeof_v2 & v2;
        typeof_m & m;
        int _member_cnt;
        type_ref( typeof_total & totalr, typeof_v2 & v2r, typeof_m & mr, ... ): total(totalr), v2(v2r), m(mr), _member_cnt(3)
        {}
    } ref( total,v2,m ) ;;

*** co_func( f,ref,i ){...} co_func_end;
    typedef typeof( ref ) typeof_ref;
    typedef typeof( i ) typeof_i;
    class f:public stCoClosure_t
    {
    public:
        typeof_ref ref;
        typeof_i i;
        int _member_cnt;
    public:
        f( typeof_ref & refr, typeof_i & ir, ... ): ref(refr), i(ir), _member_cnt(2)
        {}
        void exec()
        {
        ...
        }
    };
